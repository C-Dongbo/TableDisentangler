## PDDI_NER_XMLparse.py
#
# An XML parser for the XML generated by the PK DDI NER program (same
# as Bioportal Annotator output). This extracts the annotated concepts
# with their location in the corresponding text and then writes the
# data to JSON. 

# Author: Richard D Boyce and Peter Randall
#
# 
## This library is free software; you can redistribute it and/or
## modify it under the terms of the GNU Library General Public
## License as published by the Free Software Foundation; either
## version 2 of the License, or (at your option) any later version.

## This library is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
## Library General Public License for more details.

## You should have received a copy of the GNU Library General Public
## License along with this library; if not, write to the
## Free Software Foundation, Inc., 59 Temple Place - Suite 330,
## Boston, MA 02111-1307, USA.


from lxml import etree
import itertools
import json
import sys
import os.path
import csv

unique_annots = []
OUTpath = 'json-output/' 
if (len(sys.argv) > 1):
	source = str(sys.argv[1])
	path,fl = os.path.split(source)
	#print fl
	tree = etree.parse(source)
else:
	print "ERROR: no path specified - please specify a path for the files to be parsed."
	sys.exit(1)

class annotation:
	fullId = None
	origName = None
	preferredName = None
	fro = None
	to = None
	semTypes = []

	def __init__(self, origName, prefName, fullId, to, fro):
		self.to = to
		self.fro = fro
		self.preferredName = prefName
		self.fullId = fullId
		self.origName = origName

	def __str__(self):
		return 'Original Name: ' + self.origName + '\nPreferred Name: ' + self.preferredName +  '\nFull ID: ' + self.fullId + '\nFrom ' + self.fro + ' to ' + self.to  +'\n'
	
	def toDict(self):
		result = {'origName' : self.origName, 'preferredName' : self.preferredName, 'fullId' : self.fullId }
		return result
		 
def findAnnots():
	annots = []
	roots = tree.xpath('//annotatorResultBean')
	for root in roots:
		fD = root.xpath('//fullId')
		nm = root.xpath('//preferredName')
		orig = root.xpath('//name')
		to = root.xpath('//to')
		fro = root.xpath('//from')
		for i, o, n, t, f, s in itertools.izip(nm,orig,fD,to,fro,sem):
			smstr = []
			for each in s:
				k = each[1].text.strip()
				smstr.append(k)
			x = annotation(i.text.strip(), o.text.strip(), n.text.strip(), t.text.strip(), f.text.strip(), smstr)
			annots.append(x)
	return annots
		
def findAnnotsDDI(treepath):
    annots = []
    beans = treepath.xpath('//annotationBean')

    for bean in beans:
        if len(bean.xpath('concept/fullId'))>0:
            fd = bean.xpath('concept/fullId')[0].text.strip()
            nm = bean.xpath('concept/preferredName')[0].text.strip()
            orig = bean.xpath('context/term/name')[0].text.strip()
            to = bean.xpath('context/to')[0].text.strip()
            fro = bean.xpath('context/from')[0].text.strip()
            annot = [orig, nm, fd]
            if annot not in unique_annots:
            	unique_annots.append(annot)
            # print fd, orig, nm, to, fro
        else:
            continue
    for anno in unique_annots:
        x = annotation(nm, orig, fd, to, fro)
        annots.append(x)
    return annots

if __name__=="__main__":
	a1 = findAnnotsDDI(tree)
	a1 = list(set(a1))
	jdump = []
	for annos in a1:
		jdump.append(annos.toDict())
	with open(OUTpath + fl + '.json', 'w+') as outfile:
		json.dump(jdump, outfile)
	with open(OUTpath + fl + '.txt', 'wb') as csvfile:
		writer = csv.writer(csvfile, delimiter='\t')
		for row in unique_annots:
			writer.writerow(row)
